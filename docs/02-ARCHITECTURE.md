# Technical Architecture Document: Foundry

Generated by: System Architecture Agent v19 (Application-Agnostic)
Date: 2026-01-22
Status: Draft

Framework: Agent Specification Framework v2.1
Constitution: Agent 0 - Agent Constitution v3.3

---

## 1. Architectural Overview

### 1.1 High-Level Architecture

Foundry implements a **monolithic full-stack architecture** deployed on Replit. The application consists of a React frontend served by an Express.js backend, with PostgreSQL (Neon) for persistence. This architecture is mandated by Replit's single-container deployment model per Constitution Section D.

```
+------------------+     +------------------+     +------------------+
|                  |     |                  |     |                  |
|  React Frontend  |<--->|  Express.js API  |<--->|   PostgreSQL     |
|  (Vite/SPA)      |     |  (Node.js)       |     |   (Neon)         |
|                  |     |                  |     |                  |
+------------------+     +------------------+     +------------------+
         |                       |
         |                       v
         |               +------------------+
         |               |                  |
         +-------------->|  Local File      |
                         |  Storage         |
                         |  (Ephemeral)     |
                         +------------------+
                                 |
                                 v
                         +------------------+
                         |                  |
                         |  Teamwork Desk   |
                         |  API (External)  |
                         |                  |
                         +------------------+
```

### 1.2 Core Architecture Pattern

**Pattern:** Layered Monolith with Service Abstraction

The application uses a layered architecture within the monolith:
- **Presentation Layer:** React SPA with component-based UI
- **API Layer:** Express routes with middleware chain
- **Service Layer:** Business logic encapsulated in service modules
- **Data Access Layer:** Drizzle ORM with repository pattern
- **Infrastructure Layer:** Database, file storage, external APIs

### 1.3 System Boundaries

| Boundary | Internal/External | Protocol | Authentication |
|----------|-------------------|----------|----------------|
| Browser <-> API | Internal | HTTPS | JWT Bearer |
| API <-> PostgreSQL | Internal | TCP/SSL | Connection string |
| API <-> Teamwork Desk | External | HTTPS/REST | API Key |
| API <-> Local Storage | Internal | Filesystem | N/A |

### 1.4 Key Architectural Drivers

| Driver | Source | Architectural Impact |
|--------|--------|---------------------|
| Replit deployment | Constitution Section D | Single container, port 5000, ephemeral filesystem |
| Multi-tenant isolation | PRD FEAT-002 | Organization-scoped queries, data isolation |
| 100MB file uploads | PRD FEAT-004 | Streaming upload, chunked processing |
| 100,000 record processing | PRD FEAT-008 | Async processing, progress tracking |
| API key storage | PRD FEAT-005 | Encryption at rest (AES-256-GCM) |
| PII handling | PRD FEAT-007 | Audit logging, secure processing |

---

## 2. Technology Stack

### 2.1 Frontend Stack

| Component | Technology | Version | Rationale | Alternatives Considered |
|-----------|------------|---------|-----------|------------------------|
| Framework | React | 18.x | Industry standard, team familiarity, extensive ecosystem | Vue.js (smaller ecosystem), Svelte (less mature) |
| Build Tool | Vite | 5.x | Fast HMR, native ESM, optimal for Replit | webpack (slower), Parcel (less configurable) |
| Language | TypeScript | 5.x | Type safety, better IDE support, fewer runtime errors | JavaScript (less safe) |
| Styling | Tailwind CSS | 3.x | Utility-first, rapid development, small bundle | styled-components (runtime overhead), CSS Modules (verbose) |
| Components | shadcn/ui | Latest | High quality, accessible, customizable | MUI (heavy), Chakra (opinionated) |
| State | React Query | 5.x | Server state management, caching, optimistic updates | Redux (boilerplate), SWR (fewer features) |
| Forms | React Hook Form | 7.x | Performance, validation integration | Formik (heavier) |
| Validation | Zod | 3.x | TypeScript-first, composable schemas | Yup (less TS integration) |
| Routing | React Router | 6.x | Standard routing, nested routes | TanStack Router (newer) |

### 2.2 Backend Stack

| Component | Technology | Version | Rationale | Alternatives Considered |
|-----------|------------|---------|-----------|------------------------|
| Runtime | Node.js | 20.x LTS | Replit standard, async I/O, npm ecosystem | Deno (less mature), Bun (compatibility concerns) |
| Framework | Express.js | 4.x | Mature, minimal, extensive middleware | Fastify (newer), Koa (smaller ecosystem) |
| Language | TypeScript | 5.x | Type safety, shared types with frontend | JavaScript (less safe) |
| ORM | Drizzle ORM | Latest | Type-safe, PostgreSQL native, lightweight | Prisma (heavier), TypeORM (legacy patterns) |
| DB Driver | postgres-js | Latest | Replit-compatible, per Constitution Section D | node-postgres (less performant) |
| Validation | Zod | 3.x | Shared schemas with frontend | Joi (separate from frontend) |

### 2.3 Infrastructure Stack

| Component | Technology | Rationale | Alternatives Considered |
|-----------|------------|-----------|------------------------|
| Database | PostgreSQL (Neon) | Replit-managed, scalable, ACID compliant | SQLite (no multi-tenant), MySQL (less feature-rich) |
| Hosting | Replit | Project requirement | N/A - mandated |
| File Storage | Local filesystem | Simplicity for MVP, adequate for 100MB files | S3 (complexity), Cloudflare R2 (additional cost) |
| Process Manager | Replit native | Single container model | PM2 (not needed) |

### 2.4 Security Stack

| Component | Technology | Purpose |
|-----------|------------|---------|
| Password Hashing | bcrypt | Secure password storage (cost factor 10) |
| Token Encryption | AES-256-GCM | OAuth token / API key encryption at rest |
| Headers | Helmet | Security headers middleware |
| Rate Limiting | express-rate-limit | Brute force protection |
| CORS | cors | Cross-origin request control |

---

## 3. PRD-to-Architecture Traceability

| PRD Feature | Feature ID | Architectural Support | Components Involved |
|-------------|------------|----------------------|---------------------|
| User Authentication | FEAT-001 | JWT auth middleware, bcrypt hashing, token management | AuthService, tokens.ts, auth middleware |
| Organization Management | FEAT-002 | Multi-tenant data isolation, RBAC middleware | OrgService, role middleware, org-scoped queries |
| Project Management | FEAT-003 | CRUD services with org scoping | ProjectService, project routes |
| File Source Upload | FEAT-004 | Multer upload, file parser service, temp storage | FileService, upload middleware, parsers |
| Teamwork Desk Integration | FEAT-005 | HTTP client, credential encryption, sync service | TeamworkService, encryption.ts |
| Schema Configuration | FEAT-006 | Schema detection engine, mapping service | SchemaService, field mapper |
| PII De-identification | FEAT-007 | PII detector, masking engine, audit logging | PIIService, masking strategies |
| Processing Pipeline | FEAT-008 | Async job runner, stage executor, progress tracker | ProcessingService, pipeline executor |
| Dataset Export | FEAT-009 | Export formatters, download endpoint | ExportService, format transformers |
| User Profile | FEAT-010 | Profile service, password change with verification | UserService, profile routes |

---

## 4. Component Architecture

### 4.1 Component Diagram

```
+------------------------------------------------------------------+
|                           CLIENT                                  |
+------------------------------------------------------------------+
|  +------------------+  +------------------+  +------------------+ |
|  |   Auth Module    |  |  Project Module  |  |  Settings Module | |
|  |  - Login         |  |  - Dashboard     |  |  - Organization  | |
|  |  - Register      |  |  - Sources       |  |  - Team          | |
|  |  - Reset         |  |  - Processing    |  |  - Profile       | |
|  +------------------+  |  - Datasets      |  +------------------+ |
|                        +------------------+                       |
+------------------------------------------------------------------+
                               |
                          HTTP/REST
                               |
+------------------------------------------------------------------+
|                           SERVER                                  |
+------------------------------------------------------------------+
|  +------------------+  +------------------+  +------------------+ |
|  |   Middleware     |  |    Routes        |  |    Services      | |
|  |  - Auth          |  |  - /api/auth     |  |  - AuthService   | |
|  |  - Rate Limit    |  |  - /api/projects |  |  - ProjectSvc    | |
|  |  - Validation    |  |  - /api/sources  |  |  - SourceSvc     | |
|  |  - Error Handler |  |  - /api/process  |  |  - ProcessSvc    | |
|  |  - Org Scope     |  |  - /api/datasets |  |  - ExportSvc     | |
|  +------------------+  +------------------+  |  - PIISvc        | |
|                                             +------------------+ |
|  +------------------+  +------------------+  +------------------+ |
|  |   Data Access    |  |   External       |  |   Utilities      | |
|  |  - Drizzle ORM   |  |  - Teamwork API  |  |  - encryption.ts | |
|  |  - Repositories  |  |  - HTTP Client   |  |  - response.ts   | |
|  |  - Migrations    |  |                  |  |  - validation.ts | |
|  +------------------+  +------------------+  +------------------+ |
+------------------------------------------------------------------+
```

### 4.2 Responsibility Matrix

| Component | Responsibilities | Dependencies |
|-----------|-----------------|--------------|
| AuthService | User registration, login, password reset, token generation | tokens.ts, UserRepository |
| OrgService | Organization CRUD, invitation management | OrgRepository, InvitationRepository |
| ProjectService | Project CRUD with org scoping | ProjectRepository, org scope middleware |
| SourceService | Source creation, file parsing, API connection | FileService, TeamworkService |
| SchemaService | Field detection, mapping management | Parser modules, SchemaRepository |
| PIIService | PII detection, masking application | PII patterns, masking strategies |
| ProcessingService | Pipeline execution, progress tracking | Stage executors, job queue |
| ExportService | Dataset formatting, file generation | Format transformers |
| TeamworkService | API integration, credential management | HTTP client, encryption.ts |

### 4.3 Service Interfaces

```typescript
// Core service interfaces (for reference)

interface IAuthService {
  register(email: string, password: string, inviteToken: string): Promise<User>;
  login(email: string, password: string): Promise<{ user: User; token: string }>;
  requestPasswordReset(email: string): Promise<void>;
  resetPassword(token: string, newPassword: string): Promise<void>;
}

interface IProjectService {
  create(orgId: number, data: CreateProjectDTO): Promise<Project>;
  findAll(orgId: number): Promise<Project[]>;
  findById(orgId: number, projectId: number): Promise<Project | null>;
  update(orgId: number, projectId: number, data: UpdateProjectDTO): Promise<Project>;
  delete(orgId: number, projectId: number): Promise<void>;
}

interface IProcessingService {
  configure(projectId: number, config: ProcessingConfig): Promise<void>;
  execute(projectId: number): Promise<ProcessingRun>;
  getProgress(runId: number): Promise<ProcessingProgress>;
  cancel(runId: number): Promise<void>;
}
```

---

## 5. Authentication & Authorization

### 5.1 Authentication Flow

Per Constitution Section C, authentication uses JWT tokens stored in localStorage with 24-hour expiry.

#### 5.1.1 Registration Flow (Invite-Only)

```
1. Admin creates invitation -> Invitation record created with token
2. Invitee receives email with link containing token
3. Invitee visits /register/:token
4. System validates token (exists, not expired, not used)
5. User enters password
6. System:
   - Creates User record with hashed password (bcrypt, cost 10)
   - Links User to Organization from invitation
   - Marks invitation as used
   - Generates JWT token
7. User redirected to dashboard with token in localStorage
```

#### 5.1.2 Login Flow

```
1. User submits email + password to POST /api/auth/login
2. System:
   - Finds user by email
   - Compares password hash with bcrypt
   - If valid: generates JWT, returns { user, token }
   - If invalid: returns 401 (generic message, no email leak)
3. Client stores token in localStorage under 'auth_token'
4. Subsequent requests include Authorization: Bearer <token>
```

#### 5.1.3 Token Management

Per Constitution Section C:

```typescript
// server/lib/tokens.ts
import jwt from 'jsonwebtoken';

interface TokenPayload {
  userId: number;
  email: string;
  organizationId: number;
  role: 'admin' | 'member';
}

export function generateToken(payload: TokenPayload): string {
  return jwt.sign(payload, process.env.JWT_SECRET!, {
    expiresIn: '24h',  // Constitution default v3.1
    algorithm: 'HS256',
  });
}

export function verifyToken(token: string): TokenPayload {
  return jwt.verify(token, process.env.JWT_SECRET!) as TokenPayload;
}
```

#### 5.1.4 Logout Flow

```
1. Client calls POST /api/auth/logout (optional server-side logging)
2. Client removes 'auth_token' from localStorage
3. Client redirects to /login
```

#### 5.1.5 Password Reset Flow

```
1. User requests reset via POST /api/auth/forgot-password
2. System:
   - Finds user by email (if not found, still return success - no email leak)
   - Generates reset token (crypto.randomBytes, 1-hour expiry)
   - Stores token hash in password_resets table
   - Sends email with reset link
3. User clicks link, visits /reset-password/:token
4. User submits new password
5. System:
   - Validates token (exists, not expired)
   - Updates user password (bcrypt hash)
   - Deletes reset token
   - User redirected to login
```

### 5.2 Authorization (RBAC)

Two roles per PRD:
- **Admin:** Full access including team management, organization settings
- **Member:** Project access only (create, read, update, delete own projects)

```typescript
// server/middleware/authorize.ts
import { Request, Response, NextFunction } from 'express';
import { ForbiddenError } from '../errors';

export function requireRole(...allowedRoles: Array<'admin' | 'member'>) {
  return (req: Request, res: Response, next: NextFunction) => {
    const userRole = req.user?.role;
    
    if (!userRole || !allowedRoles.includes(userRole)) {
      throw new ForbiddenError('Insufficient permissions');
    }
    
    next();
  };
}

// Usage:
router.post('/invitations', requireRole('admin'), invitationController.create);
router.get('/projects', requireRole('admin', 'member'), projectController.list);
```

### 5.3 Organization Scope Middleware

All data access must be scoped to the user's organization:

```typescript
// server/middleware/org-scope.ts
import { Request, Response, NextFunction } from 'express';

export function enforceOrgScope(req: Request, res: Response, next: NextFunction) {
  // Attach org context from JWT for all queries
  res.locals.organizationId = req.user!.organizationId;
  next();
}

// All repository methods use this:
async function findProjects(orgId: number): Promise<Project[]> {
  return db.query.projects.findMany({
    where: eq(projects.organizationId, orgId),
  });
}
```

---

## 6. Response Envelope Specification

All API responses use standardized envelope structures for consistency and frontend integration reliability.

### 6.1 Success Response Structure

```json
{
  "data": { ... },
  "meta": {
    "timestamp": "2026-01-22T10:30:00.000Z",
    "requestId": "uuid-v4"
  }
}
```

**Fields:**
- `data`: The actual response payload (object or primitive)
- `meta.timestamp`: ISO-8601 timestamp of response generation
- `meta.requestId`: Unique request identifier for tracing

### 6.2 Paginated Response Structure

```json
{
  "data": [ ... ],
  "meta": {
    "timestamp": "2026-01-22T10:30:00.000Z",
    "requestId": "uuid-v4",
    "pagination": {
      "page": 1,
      "pageSize": 20,
      "total": 100,
      "totalPages": 5,
      "hasMore": true
    }
  }
}
```

**Additional Fields:**
- `data`: Array of items for current page
- `meta.pagination.page`: Current page number (1-indexed)
- `meta.pagination.pageSize`: Items per page
- `meta.pagination.total`: Total items across all pages
- `meta.pagination.totalPages`: Calculated total pages
- `meta.pagination.hasMore`: Boolean indicating more pages available

### 6.3 Error Response Structure

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid email format",
    "details": {
      "field": "email",
      "value": "not-an-email"
    }
  },
  "meta": {
    "timestamp": "2026-01-22T10:30:00.000Z",
    "requestId": "uuid-v4"
  }
}
```

**Fields:**
- `error.code`: Machine-readable error identifier (e.g., VALIDATION_ERROR, UNAUTHORIZED)
- `error.message`: Human-readable error message
- `error.details`: Optional additional context (validation errors, etc.)
- `meta`: Same as success responses

### 6.4 Response Helper Functions

All routes MUST use these helpers to ensure envelope consistency:

```typescript
// server/lib/response.ts

import { Response } from 'express';
import crypto from 'crypto';

export function sendSuccess(res: Response, data: any) {
  return res.json({
    data,
    meta: {
      timestamp: new Date().toISOString(),
      requestId: res.locals.requestId || crypto.randomUUID(),
    },
  });
}

export function sendCreated(res: Response, data: any) {
  return res.status(201).json({
    data,
    meta: {
      timestamp: new Date().toISOString(),
      requestId: res.locals.requestId || crypto.randomUUID(),
    },
  });
}

export function sendPaginated(
  res: Response,
  data: any[],
  pagination: { page: number; pageSize: number; total: number }
) {
  const totalPages = Math.ceil(pagination.total / pagination.pageSize);
  const hasMore = pagination.page < totalPages;

  return res.json({
    data,
    meta: {
      timestamp: new Date().toISOString(),
      requestId: res.locals.requestId || crypto.randomUUID(),
      pagination: {
        page: pagination.page,
        pageSize: pagination.pageSize,
        total: pagination.total,
        totalPages,
        hasMore,
      },
    },
  });
}

export function sendNoContent(res: Response) {
  return res.status(204).send();
}
```

### 6.5 Enforcement

- Agent 4 (API Contract) uses these structures in all response examples
- Agent 6 (Implementation) includes response.ts in MANDATORY files
- Agent 7 (QA) verifies no direct res.json() calls bypass helpers

---

## 7. Sensitive Data Encryption Specification

### 7.1 Encryption Requirements

This application stores sensitive data that requires encryption at rest:

| Data Type | Storage Location | Encryption Required |
|-----------|-----------------|---------------------|
| Teamwork API Keys | sources.api_key | Yes - AES-256-GCM |
| OAuth Access Tokens (future) | integrations.access_token | Yes - AES-256-GCM |
| OAuth Refresh Tokens (future) | integrations.refresh_token | Yes - AES-256-GCM |

**Zero-Tolerance Rule:** OAuth tokens, API keys, and sensitive secrets MUST be encrypted before database storage. Code with `// TODO: Encrypt` comments in these paths is a deployment blocker.

### 7.2 Encryption Implementation

**Algorithm:** AES-256-GCM (Galois/Counter Mode)
- Key Size: 256 bits (32 bytes)
- IV Size: 128 bits (16 bytes, randomly generated per encryption)
- Authentication Tag: 128 bits (16 bytes)

**Why AES-256-GCM:**
- Industry standard for symmetric encryption
- Authenticated encryption (prevents tampering)
- Fast performance
- Built into Node.js crypto module

### 7.3 Encryption Utility Specification

Full implementation required in `server/lib/encryption.ts`:

```typescript
import crypto from 'crypto';

const ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 16;
const TAG_LENGTH = 16;

function getKey(): Buffer {
  if (!process.env.ENCRYPTION_KEY) {
    throw new Error('ENCRYPTION_KEY environment variable is required');
  }
  return Buffer.from(process.env.ENCRYPTION_KEY, 'hex');
}

/**
 * Encrypt sensitive data before database storage.
 * @param text - Plain text to encrypt
 * @returns Encrypted text in format: iv:encrypted:authTag (hex encoded)
 */
export function encrypt(text: string): string {
  const key = getKey();
  const iv = crypto.randomBytes(IV_LENGTH);
  const cipher = crypto.createCipheriv(ALGORITHM, key, iv);
  
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const authTag = cipher.getAuthTag();
  
  return `${iv.toString('hex')}:${encrypted}:${authTag.toString('hex')}`;
}

/**
 * Decrypt sensitive data retrieved from database.
 * @param encryptedText - Encrypted text from encrypt()
 * @returns Decrypted plain text
 */
export function decrypt(encryptedText: string): string {
  const key = getKey();
  const [ivHex, encrypted, authTagHex] = encryptedText.split(':');
  
  if (!ivHex || !encrypted || !authTagHex) {
    throw new Error('Invalid encrypted data format');
  }

  const iv = Buffer.from(ivHex, 'hex');
  const authTag = Buffer.from(authTagHex, 'hex');
  
  const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);
  decipher.setAuthTag(authTag);
  
  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
}

/**
 * Generate a new encryption key for setup or rotation.
 */
export function generateEncryptionKey(): string {
  return crypto.randomBytes(32).toString('hex');
}
```

### 7.4 Key Management

**Environment Variable:**
```bash
ENCRYPTION_KEY=[64 hex characters]  # REQUIRED
```

**Generation:**
```bash
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
```

**Validation:** Startup check ensures key is exactly 64 hex characters.

**Rotation Strategy:**
1. Generate new key
2. Decrypt all sensitive data with old key
3. Re-encrypt with new key
4. Update ENCRYPTION_KEY environment variable
5. Restart application

**Key Loss:** If ENCRYPTION_KEY is lost, all encrypted data is unrecoverable. CRITICAL: Back up key securely.

### 7.5 Usage Pattern

**Storing Teamwork API Key:**
```typescript
import { encrypt } from '../lib/encryption';

async function saveTeamworkCredentials(sourceId: number, apiKey: string) {
  const encryptedKey = encrypt(apiKey);
  
  await db.update(sources)
    .set({ apiKey: encryptedKey })
    .where(eq(sources.id, sourceId));
}
```

**Retrieving Teamwork API Key:**
```typescript
import { decrypt } from '../lib/encryption';

async function getTeamworkClient(sourceId: number) {
  const source = await db.query.sources.findFirst({
    where: eq(sources.id, sourceId),
  });
  
  if (!source?.apiKey) return null;
  
  const apiKey = decrypt(source.apiKey);
  return new TeamworkClient(apiKey);
}
```

### 7.6 Database Schema Considerations

Encrypted data stored as TEXT (hex-encoded format: `iv:encrypted:authTag`).

---

## 8. Security Architecture (MVP)

### 8.1 Security Middleware Stack

```typescript
// server/middleware/security.ts
import helmet from 'helmet';
import cors from 'cors';

export function setupSecurityMiddleware(app: Express) {
  // Security headers
  app.use(helmet({
    contentSecurityPolicy: false,  // Relaxed for SPA
  }));
  
  // CORS configuration
  app.use(cors({
    origin: process.env.NODE_ENV === 'production' 
      ? process.env.APP_URL 
      : true,
    credentials: true,
  }));
}
```

### 8.2 Rate Limiting

```typescript
// server/middleware/rate-limit.ts
import rateLimit from 'express-rate-limit';

// Global rate limiter
export const globalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,  // 15 minutes
  max: 100,
  standardHeaders: true,
  legacyHeaders: true,
  message: { 
    error: { code: 'RATE_LIMITED', message: 'Too many requests' } 
  },
});

// Stricter auth limiter
export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 10,
  standardHeaders: true,
  legacyHeaders: true,
  message: { 
    error: { code: 'RATE_LIMITED', message: 'Too many login attempts' } 
  },
});
```

### 8.3 Input Validation

All inputs validated with Zod schemas:

```typescript
// shared/schemas/auth.ts
import { z } from 'zod';

export const loginSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(1, 'Password required'),
});

export const registerSchema = z.object({
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[a-z]/, 'Password must contain lowercase letter')
    .regex(/[A-Z]/, 'Password must contain uppercase letter')
    .regex(/[0-9]/, 'Password must contain number'),
});
```

### 8.4 URL Parameter Validation

```typescript
// server/lib/validation.ts
import { BadRequestError } from '../errors';

export function parseIntParam(value: string, paramName: string): number {
  const parsed = parseInt(value, 10);
  if (!Number.isFinite(parsed) || parsed < 1) {
    throw new BadRequestError(`Invalid ${paramName}`);
  }
  return parsed;
}
```

### 8.5 Security Requirements Summary

| Area | Requirement | Implementation |
|------|-------------|----------------|
| Security Headers | Helmet middleware configured | setupSecurityMiddleware() |
| CORS | Origin-restricted in production | cors() with APP_URL |
| Rate Limiting | Global + auth limiter | express-rate-limit |
| Password Hashing | bcrypt cost factor >= 10 | bcrypt.hash(password, 10) |
| Token Encryption | AES-256-GCM for API keys | encryption.ts |
| Input Validation | Zod schemas for all inputs | Shared schema validation |
| Token Expiry | JWT tokens: 24h | Constitution Section C |

---

## 9. Data Architecture Overview

### 9.1 Data Flow

```
+----------------+     +-----------------+     +------------------+
|  File Upload   |---->|  Parser Service |---->|  Source Cache    |
|  (CSV/XLS/JSON)|     |  (Detection)    |     |  (30-day TTL)    |
+----------------+     +-----------------+     +------------------+
                                                      |
+----------------+     +-----------------+             v
|  Teamwork API  |---->|  Sync Service   |---->+------------------+
|  (REST)        |     |  (Incremental)  |     |  Schema Mapping  |
+----------------+     +-----------------+     +------------------+
                                                      |
                                                      v
                                              +------------------+
                                              |  Processing      |
                                              |  Pipeline        |
                                              +------------------+
                                                      |
                                                      v
                                              +------------------+
                                              |  Dataset         |
                                              |  (Export Ready)  |
                                              +------------------+
```

### 9.2 Storage Strategy

| Data Type | Storage | Retention | Rationale |
|-----------|---------|-----------|-----------|
| User data | PostgreSQL | Permanent | Core entity data |
| File uploads | Local filesystem | 30 days | Per PRD, supports re-processing |
| Source cache | PostgreSQL (JSONB) | 30 days | Parsed data for re-use |
| Processed datasets | PostgreSQL (JSONB) | Until deleted | User-created output |
| Audit logs | PostgreSQL | 90 days | Compliance requirement |

### 9.3 Caching Strategy

| Cache Type | Implementation | TTL | Invalidation |
|------------|----------------|-----|--------------|
| Auth tokens | In-memory (JWT) | 24h | Token expiry |
| User sessions | None (stateless) | N/A | N/A |
| Query results | React Query | 5 min | On mutation |
| Parsed files | PostgreSQL | 30 days | TTL or manual delete |

---

## 10. Third-Party Integrations

### 10.1 Teamwork Desk API

| Attribute | Value |
|-----------|-------|
| Classification | REQUIRED (MVP) |
| API Type | REST |
| Authentication | API Key (encrypted at rest) |
| Base URL | https://{subdomain}.teamwork.com/desk/v1 |
| Rate Limits | 100 requests/minute |
| Cost | Included in Teamwork subscription |

**Endpoints Used:**
- `GET /tickets` - List support tickets
- `GET /tickets/{id}/messages` - Get conversation messages
- `GET /customers` - List customers (for de-identification)

**Failure Modes:**
| Failure | Detection | Recovery |
|---------|-----------|----------|
| Invalid credentials | 401 response | Prompt user to re-enter API key |
| Rate limited | 429 response | Exponential backoff, queue remaining |
| API unavailable | 5xx response | Retry with backoff, max 3 attempts |
| Network timeout | Connection error | Retry with backoff |

**Fallback Behavior:**
- If Teamwork unavailable during sync: Queue job, retry later
- If rate limited: Continue available items, complete when limit resets
- User can always fall back to manual file upload

---

## 11. Replit Deployment Configuration

### 11.1 .replit File

```toml
run = "npm run start"
entrypoint = "server/index.ts"

[nix]
channel = "stable-24_05"

[deployment]
run = ["sh", "-c", "npm run start"]
deploymentTarget = "cloudrun"

[[ports]]
localPort = 5000
externalPort = 80
```

### 11.2 Environment Variables

| Variable | Type | Description | Example |
|----------|------|-------------|---------|
| DATABASE_URL | REQUIRED | PostgreSQL connection string | postgres://... |
| JWT_SECRET | REQUIRED | JWT signing secret (min 32 chars) | [random string] |
| ENCRYPTION_KEY | REQUIRED | AES-256 key (64 hex chars) | [64 hex chars] |
| NODE_ENV | REQUIRED | Environment mode | production |
| APP_URL | OPTIONAL | Application URL for CORS | https://foundry.replit.app |
| SENDGRID_API_KEY | OPTIONAL | Email service (degrades gracefully) | SG.xxx |

### 11.3 Startup Validation

```typescript
// server/config.ts
const REQUIRED_ENV_VARS = [
  'DATABASE_URL',
  'JWT_SECRET',
  'ENCRYPTION_KEY',
];

export function validateEnvironment() {
  const missing = REQUIRED_ENV_VARS.filter(key => !process.env[key]);
  
  if (missing.length > 0) {
    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
  }
  
  // Validate ENCRYPTION_KEY format
  if (!/^[0-9a-f]{64}$/i.test(process.env.ENCRYPTION_KEY!)) {
    throw new Error('ENCRYPTION_KEY must be 64 hex characters (32 bytes)');
  }
}
```

### 11.4 Port Configuration

Per Constitution Section C:

| Environment | Frontend | Backend | Notes |
|-------------|----------|---------|-------|
| Production | 5000 | 5000 | Single Express server serves both |
| Development | 5000 (Vite) | 3001 (Express) | Vite proxies /api/* to Express |

### 11.5 Vite Configuration

```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    host: '0.0.0.0',  // Required for Replit
    port: 5000,
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true,
      },
    },
    watch: {
      usePolling: true,  // Required for Replit filesystem
      interval: 1000,
    },
  },
  build: {
    outDir: 'dist/public',
    emptyOutDir: true,
  },
});
```

---

## 12. Architecture Decision Records

### ADR-001: Monolithic Architecture

**Context:** Foundry requires deployment on Replit which only supports single-container deployments. The MVP has modest scale requirements (10-50 concurrent users).

**Decision:** Implement as a monolithic full-stack application with Express serving both API and static frontend in production.

**Alternatives Considered:**
1. Microservices (separate processing service) - Rejected: Replit incompatible
2. Serverless functions - Rejected: Cold start issues, complexity
3. Separate frontend/backend containers - Rejected: Replit single-container only

**Consequences:**
- Positive: Simple deployment, shared code, lower operational complexity
- Negative: All scaling is vertical, processing shares resources with API
- Trade-off: Acceptable for MVP scale; can extract services later if needed

---

### ADR-002: Local File Storage

**Context:** Foundry needs to store uploaded files (up to 100MB) for processing and re-processing with 30-day retention.

**Decision:** Use Replit's local filesystem for file storage with UUID-based naming and metadata stored in PostgreSQL.

**Alternatives Considered:**
1. AWS S3 - Rejected: Additional cost, complexity, external dependency
2. Cloudflare R2 - Rejected: Similar to S3, unnecessary for MVP
3. PostgreSQL BYTEA - Rejected: Large blobs hurt DB performance

**Consequences:**
- Positive: Zero additional cost, simple implementation, fast local I/O
- Negative: Files lost if container restarts (mitigated by metadata for re-upload)
- Trade-off: Acceptable for MVP; can migrate to cloud storage later

**Mitigation:** Store file metadata in PostgreSQL; UI prompts re-upload if file missing.

---

### ADR-003: Asynchronous Processing Model

**Context:** Processing pipelines can handle up to 100,000 records with multiple transformation stages, potentially taking 30+ minutes.

**Decision:** Implement async processing with job queue pattern using PostgreSQL as the queue backend.

**Alternatives Considered:**
1. Synchronous processing - Rejected: Timeout issues, poor UX
2. Redis queue (BullMQ) - Rejected: Additional infrastructure
3. External queue (SQS) - Rejected: Replit limitations

**Consequences:**
- Positive: Long-running jobs supported, progress tracking possible, user can navigate away
- Negative: PostgreSQL not optimized for queue operations
- Trade-off: Adequate for MVP volume; can add dedicated queue later

**Implementation:** 
- processing_jobs table with status, progress, error columns
- Polling endpoint for progress updates
- Background job runner checking queue every 5 seconds

---

### ADR-004: Drizzle ORM Selection

**Context:** Need type-safe database access with PostgreSQL on Replit, per Constitution Section D requiring postgres-js driver.

**Decision:** Use Drizzle ORM with postgres-js driver for all database operations.

**Alternatives Considered:**
1. Prisma - Rejected: Heavier, requires generation step, binary compatibility issues
2. TypeORM - Rejected: Legacy patterns, less type-safe
3. Raw SQL - Rejected: No type safety, more verbose

**Consequences:**
- Positive: Type-safe queries, lightweight, PostgreSQL-native features
- Negative: Smaller ecosystem than Prisma
- Trade-off: Right balance of type safety and simplicity for this project

---

### ADR-005: AES-256-GCM for Sensitive Data

**Context:** Application stores Teamwork Desk API keys that must be encrypted at rest per security requirements.

**Decision:** Implement application-level encryption using AES-256-GCM for all API keys and future OAuth tokens.

**Alternatives Considered:**
1. Database-level encryption (TDE) - Rejected: Not available in Replit PostgreSQL
2. No encryption - Rejected: Security risk, fails compliance
3. AES-256-CBC - Rejected: No authentication (GCM provides integrity)

**Consequences:**
- Positive: Strong encryption, tamper detection, Node.js built-in support
- Negative: ENCRYPTION_KEY loss = data loss, slight performance overhead
- Trade-off: Security requirement outweighs complexity; key backup is mandatory

---

### ADR-006: Response Envelope Standardization

**Context:** Inconsistent API responses cause frontend integration issues and debugging difficulty.

**Decision:** All API responses must use standardized envelope structures with mandatory helper functions.

**Alternatives Considered:**
1. Direct JSON responses - Rejected: Inconsistency across endpoints
2. GraphQL - Rejected: Over-engineering for this use case
3. Custom per-endpoint formats - Rejected: Maintenance nightmare

**Consequences:**
- Positive: Consistent frontend parsing, built-in metadata, easier debugging
- Negative: Slight payload overhead from meta wrapper
- Trade-off: Consistency benefits outweigh minimal overhead

---

### ADR-007: PostgreSQL-Based Job Queue

**Context:** Need to queue and process long-running data transformation jobs without external dependencies.

**Decision:** Implement job queue using PostgreSQL table with polling-based worker.

**Alternatives Considered:**
1. BullMQ (Redis) - Rejected: Requires Redis, adds infrastructure
2. AWS SQS - Rejected: External dependency, Replit limitations
3. In-memory queue - Rejected: Lost on restart

**Consequences:**
- Positive: No additional infrastructure, durable jobs, transactional guarantees
- Negative: Polling overhead, not optimized for high-throughput queuing
- Trade-off: Acceptable for MVP job volume (tens of jobs/day)

---

## 13. Validation Footer

### Completeness Checklist

- [x] All PRD features have architectural support
- [x] Technology stack complete with rationale
- [x] Auth flows fully specified
- [x] Integrations classified (required/optional)
- [x] Replit configuration complete
- [x] Security middleware specified
- [x] Response envelope specification included (success, paginated, error)
- [x] Sensitive data encryption specification included (Teamwork API keys)
- [x] Minimum 5 ADRs documented (7 total)

### Audit Prevention Summary

This Architecture addresses 2 common production issues:
- **Sensitive Data Encryption**: Specification for API keys encryption using AES-256-GCM
- **Response Envelope**: Explicit structure definitions with helper function specifications

### Prompt Hygiene Gate (Constitution Section L)

- [x] Framework Version header present and correct
- [x] Encoding scan: No non-ASCII artifact tokens
- [x] Inheritance references Constitution v3.3
- [x] No full global rule restatements (uses "Per Constitution Section X")

### Confidence Scores

| Section | Score (1-10) | Notes |
|---------|--------------|-------|
| Technology Stack | 9 | Standard, proven choices |
| Authentication | 9 | Per Constitution, well-defined |
| Response Envelopes | 10 | Explicit specification |
| Encryption | 9 | Industry standard, complete spec |
| Processing Architecture | 8 | Async model appropriate; queue polling is tradeoff |
| File Storage | 7 | Local storage acceptable for MVP; migration path clear |
| Overall | 9 | Solid foundation for MVP |

### Document Status: COMPLETE

---

## 14. Downstream Agent Handoff Brief

### Global Platform Context (All Agents)

Per Constitution Section C: Standard response/error envelopes, auth storage, API conventions apply.
Per Constitution Section D: Replit platform non-negotiables (postgres-js driver, ports, deployment model).

### Agent 3: Data Modeling

- PostgreSQL via Replit managed DB; postgres-js driver (Constitution Section D)
- ORM: Drizzle ORM (Core Select API only)
- Connection: Pool with caching enabled (max: 10, idle_timeout: 20)
- Key entities: User, Organization, Invitation, Project, Source, SchemaMapping, DeidentificationConfig, ProcessingConfig, ProcessingRun, Dataset
- **CRITICAL:** Encrypted columns (api_key) are TEXT type storing hex format `iv:encrypted:authTag`
- Multi-tenant: All tables with organization_id must be scoped in queries
- File metadata stored in sources table; actual files on filesystem

### Agent 4: API Contract

- Framework: Express.js
- **CRITICAL:** Response envelopes: Use structures defined in Architecture Section 6
- Auth: JWT Bearer tokens (Constitution Section C, 24h expiry)
- All success responses use `{ data, meta }` envelope
- All paginated responses include `meta.pagination` with 5 fields
- All errors use `{ error, meta }` envelope
- Rate limiting: Global (100/15min), Auth (10/15min)

### Agent 5: UI/UX Specification

- Framework: React + Vite
- Components: shadcn/ui
- Styling: Tailwind CSS with CSS variables
- State: React Query for server state
- Forms: React Hook Form + Zod
- Auth: Token in localStorage, 401 redirects to /login

### Agent 6: Implementation Orchestrator

- Security middleware: helmet, cors, express-rate-limit, morgan
- Graceful shutdown handler required
- parseIntParam validation required
- Route registration: specific before parameterized
- **CRITICAL:** Include response.ts in MANDATORY files (sendSuccess, sendCreated, sendPaginated, sendNoContent)
- **CRITICAL:** Include encryption.ts in MANDATORY files (encrypt, decrypt, generateEncryptionKey)
- Processing jobs via PostgreSQL queue pattern

### Agent 7: QA & Deployment

- Health endpoint format: Constitution Section C (`GET /api/health`)
- Deployment verification checklist provided
- **CRITICAL:** Verify no direct res.json() calls (all use helpers)
- **CRITICAL:** Verify no plaintext storage of API keys (grep for unencrypted storage)
- Environment variable validation at startup

---

## ASSUMPTION REGISTER

### AR-001: File Storage Strategy

- **Type:** ASSUMPTION
- **Source Gap:** PRD mentions 30-day file caching but doesn't specify storage location
- **Assumption Made:** Local filesystem storage is acceptable for MVP
- **Impact if Wrong:** Need to implement cloud storage (S3/R2) integration
- **Proposed Resolution:** Monitor file persistence across container restarts; plan cloud migration if needed
- **Status:** ACCEPTED (documented trade-off in ADR-002)
- **Owner:** Agent 2
- **Date:** 2026-01-22

### AR-002: Processing Queue Implementation

- **Type:** ASSUMPTION
- **Source Gap:** PRD specifies async processing but doesn't mandate queue technology
- **Assumption Made:** PostgreSQL-based queue is sufficient for MVP volume
- **Impact if Wrong:** May need dedicated queue (Redis/BullMQ) for higher throughput
- **Proposed Resolution:** Monitor job throughput and latency; prepared for migration path
- **Status:** ACCEPTED (documented trade-off in ADR-007)
- **Owner:** Agent 2
- **Date:** 2026-01-22

### AR-003: Email Service Optional

- **Type:** ASSUMPTION
- **Source Gap:** PRD mentions email for invitations and password reset but no specific provider
- **Assumption Made:** Email service (SendGrid) is optional; can use console logging for development
- **Impact if Wrong:** Production needs email configuration before user invitations work
- **Proposed Resolution:** SendGrid integration as OPTIONAL env var; degrades to logging if missing
- **Status:** UNRESOLVED (needs confirmation before production)
- **Owner:** Human
- **Date:** 2026-01-22

---

## Document End
